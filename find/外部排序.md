外部排序的总时间 = 内部排序时间 + 外存信息读/写的时间 + 内部归并的时间

> 磁盘读/写的机械动作所需要的时间远远超过在内存中进行运算的时间。因此，外部排序过程中的时间代价主要考虑访问磁盘的次数，即I/O次数。



若总的记录个数为$n$

缓冲区能容纳个数为$m$

则，初始归并段为$r = \lceil \frac n m \rceil$个。

归并趟数$S$ = 树的高度$h$ - 1 = $\lceil log_{k}r \rceil$



外部排序优化：

- 增加归并路数$k$，进行多路平衡归并
- 减少初始归并段数量$r$



> k路归并排序和k路平衡归并排序区别
>
> [多路平衡归并](https://blog.csdn.net/weixin_45825865/article/details/126125703?spm=1001.2014.3001.5501)
> 每次选出最小/最大元素都需要k-1次
> ①最多只能有k个段归并为一个
> ②每一趟归并中，若有m个归并段参与归并，则经过一趟处理得到$\lceil \frac m k \rceil$个新的归并段



## 败者树

败者树是树形选择排序的一种变体，可视为一棵完全二叉树。通过败者树，可以在k个归并段中选出最小关键字所需要的关键字对比次数更少。

绿色为叶子结点，存放初始数据
黑色为失败结点
蓝色为胜出结点

![image-20240324231026422](%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F.assets/image-20240324231026422.png)



败者树使用多路平衡归并，大大减少了归并趟数

败者树总结：
①败者树可视为一棵完全二叉树
②k个叶结点分别对应k个归并段中当前参加比较的元素，非叶子结点用来记录左右子树中的失败者，而让胜者往上继续进行比较，一直到根结点
③第一次选出最小需要对比关键字k-1次，第二次起最多需要$\lceil log_2k \rceil$。或者说：对于k路归并，第一次构造败者树需要对比关键字k-1次，有了败者树，选出最小元素最多需要对比关键字$\lceil log_2k \rceil$

## 置换-选择排序

置换-选择排序是一种排序算法，它通过在未排序的元素中选择最小的元素并将其放置在已排序的部分的末尾来逐步将列表排序。具体过程如下：

从列表中选择最小的元素，并将其与列表中第一个元素交换位置。
在剩余的未排序列表中选择最小的元素，并将其与列表中第二个元素交换位置。
以此类推，直到所有元素都已排好序。
该算法的时间复杂度为$O(n^2)$，其中n是待排序元素的数量。

## 最佳归并树

**归并过程中磁盘I/O次数 = $WPL \times 2$**



对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要**补充几个长度为0的虚段，再进行k叉哈夫曼的构造**。



初始归并段数量 + 虚段数量 = $n_0$
$$
n = n_o + n_k \\
k \times n_k = n - 1
$$
推出：
$$
n_0 = (k - 1) \times n_k + 1
$$
得到：
$$
n_k = \frac {n_0 - 1} {k - 1}
$$


若$(n_0 - 1)(k - 1) = u != 0$，则有$u$个是多余的，需要再**添加**$k - u - $个空归并段，就可以构建归并树。